<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Architecture · Artificial Persistent Intelligence</title>
  <link href="https://fonts.googleapis.com/css2?family=Syne:wght@600;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --black:  #0a0a0a;
      --white:  #f0f0f0;
      --grey:   #888;
      --accent: #ff3333;
      --wolf:   #ff6600;
      --dim:    #333;
      --dark:   #111;
    }
    * { box-sizing: border-box; }
    body { margin: 0; background: var(--black); color: var(--white); font-family: 'Space Mono', monospace; line-height: 1.6; }
    a { color: inherit; text-decoration: none; }
    .nav { position: fixed; top: 0; left: 0; right: 0; background: rgba(10,10,10,0.9); backdrop-filter: blur(6px); border-bottom: 1px solid var(--dim); z-index: 1000; }
    .nav .inner { max-width: 1100px; margin: 0 auto; padding: 16px 20px; display: flex; align-items: center; justify-content: space-between; gap: 16px; }
    .brand { font-family: 'Syne', sans-serif; font-size: 1.05rem; letter-spacing: 0.08em; text-transform: uppercase; }
    .nav-links { display: flex; gap: 14px; align-items: center; }
    .nav-links a { padding: 8px 10px; border-radius: 8px; transition: background 0.2s ease, color 0.2s ease; color: var(--grey); }
    .nav-links a:hover, .nav-links a:focus { background: var(--dark); color: var(--white); }
    .menu-toggle { display: none; background: var(--dark); color: var(--white); border: 1px solid var(--dim); border-radius: 8px; padding: 8px 10px; font-family: 'Space Mono', monospace; }
    main { padding: 120px 20px 80px; max-width: 1100px; margin: 0 auto; }
    .hero { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 24px; align-items: center; margin-bottom: 48px; }
    .hero h1 { font-family: 'Syne', sans-serif; font-size: clamp(2.2rem, 4vw, 3.2rem); margin: 0 0 12px; letter-spacing: -0.02em; }
    .tag { display: inline-flex; align-items: center; gap: 8px; padding: 8px 12px; border: 1px solid var(--dim); border-radius: 999px; background: var(--dark); color: var(--grey); font-size: 0.9rem; }
    .section { margin: 48px 0; border: 1px solid var(--dim); border-radius: 16px; padding: 24px; background: var(--dark); }
    .section h2 { font-family: 'Syne', sans-serif; margin: 0 0 12px; font-size: 1.6rem; letter-spacing: -0.01em; }
    .grid { display: grid; gap: 18px; grid-template-columns: repeat(auto-fit, minmax(240px, 1fr)); }
    .card { padding: 18px; border: 1px solid var(--dim); border-radius: 12px; background: linear-gradient(145deg, #0c0c0c, #0e0e0e); min-height: 140px; }
    .card h3 { font-family: 'Syne', sans-serif; margin: 0 0 10px; font-size: 1.2rem; }
    .meta { color: var(--grey); font-size: 0.95rem; }
    .list { padding-left: 18px; color: var(--white); }
    .cta-row { display: flex; gap: 14px; flex-wrap: wrap; margin-top: 16px; }
    .btn { padding: 12px 16px; border-radius: 10px; border: 1px solid var(--accent); background: var(--accent); color: var(--black); font-weight: 700; letter-spacing: 0.02em; transition: transform 0.15s ease, box-shadow 0.15s ease; font-family: 'Syne', sans-serif; }
    .btn.secondary { background: transparent; color: var(--white); border-color: var(--dim); }
    .btn:hover { transform: translateY(-2px); box-shadow: 0 10px 30px rgba(255,51,51,0.2); }
    .fade { opacity: 0; transform: translateY(18px); transition: opacity 0.6s ease, transform 0.6s ease; }
    .fade.visible { opacity: 1; transform: translateY(0); }
    footer { margin-top: 60px; padding: 20px 0 10px; color: var(--grey); font-size: 0.95rem; }
    @media (max-width: 760px) {
      .nav .inner { align-items: flex-start; }
      .menu-toggle { display: inline-flex; }
      .nav-links { position: absolute; top: 62px; left: 0; right: 0; flex-direction: column; padding: 12px 20px; background: var(--dark); border-top: 1px solid var(--dim); display: none; }
      .nav-links.open { display: flex; }
      main { padding-top: 120px; }
    }
  </style>
</head>
<body>
  <header class="nav">
    <div class="inner">
      <div class="brand">Artificial Persistent Intelligence</div>
      <button class="menu-toggle" aria-label="Toggle navigation">Menu</button>
      <nav class="nav-links" aria-label="Primary">
        <a href="index.html">Home</a>
        <a href="manifesto.html">Manifesto</a>
        <a href="wolf.html">Identity Signal</a>
        <a href="architecture.html">Architecture</a>
        <a href="contact.html">Contact</a>
      </nav>
    </div>
  </header>

  <main>
    <section class="architecture-page">
      <div class="architecture-inner">

        <h1>Artificial Persistent Intelligence</h1>
        <h2>The Core Algorithm</h2>

        <p>
          Artificial Persistent Intelligence (API) is not a chatbot.
          It is a closed-loop system designed to align with a single authenticated individual
          and continuously optimize their outcomes while preventing drift, compromise, and misuse.
        </p>

        <p><strong>API runs one persistent loop:</strong></p>
        <p><strong>OBSERVE → MODEL → PROPOSE → VALIDATE → EXECUTE → AUDIT → LEARN</strong></p>

        <h3>1. OBSERVE</h3>
        <p>
          API captures only what the user explicitly authorizes:
        </p>
        <ul>
          <li>Stated goals and active intentions</li>
          <li>Environmental context (time, device, workload)</li>
          <li>Connected systems (if granted)</li>
          <li>Historical outcomes</li>
          <li>Risk posture and constraint boundaries</li>
        </ul>
        <p>No ambient harvesting. No unnecessary collection.</p>

        <h3>2. MODEL</h3>
        <p>
          API maintains a private user model:
        </p>
        <ul>
          <li>Long-term goals</li>
          <li>Short-term objectives</li>
          <li>Personal constraints (time, money, energy, obligations)</li>
          <li>Execution capability</li>
          <li>Behavioral patterns</li>
          <li>Historical success and failure signals</li>
        </ul>
        <p>The model evolves from real outcomes — not engagement metrics.</p>

        <h3>3. PROPOSE</h3>
        <p>API generates ranked action proposals:</p>
        <ul>
          <li>Advisory actions (recommendations)</li>
          <li>Assistive actions (drafts, preparation, automation support)</li>
          <li>Executable actions (within authorized scope only)</li>
        </ul>
        <p>Each proposal includes expected benefit, cost, data touched, required permissions, and a reversibility plan.</p>

        <h3>4. VALIDATE (Integrity Gate)</h3>
        <p>No action proceeds without validation.</p>
        <ul>
          <li>Identity confidence</li>
          <li>Permission scope</li>
          <li>Intent alignment</li>
          <li>Risk threshold compliance</li>
          <li>Data minimization</li>
          <li>Reversibility</li>
          <li>Drift detection</li>
        </ul>
        <p>If any gate fails, the action is blocked, logged, and requires explicit confirmation.</p>

        <h3>5. EXECUTE</h3>
        <p>
          If validated, API executes at the lowest necessary level of autonomy.
          Advisory by default. Automation only where explicitly granted.
        </p>

        <h3>6. AUDIT</h3>
        <p>
          Every proposal, decision, and execution is written to an append-only log.
          The audit record is user-owned and reviewable.
        </p>

        <h3>7. LEARN</h3>
        <p>
          API updates its user model only from measurable outcomes.
          It learns from reality, not conversation length.
        </p>

        <hr>

        <h2>Formal Model of API</h2>

        <p>
          Artificial Persistent Intelligence can be described as a constrained decision system
          operating over a personalized state space.
        </p>

        <pre><code>
Let:

S_t = User state at time t
M_t = User model at time t
A_t = Candidate action set
R(a) = Expected outcome value
C(a) = Cost function (time, energy, risk)
P(a) = Permission function
I(a) = Intent alignment score
D(a) = Drift score
L_t = Immutable audit log
        </code></pre>

        <h3>State Update</h3>
        <pre><code>
S_t = f(user inputs, context, history, constraints)

M_t = g(M_{t-1}, S_t, outcomes)
        </code></pre>

        <h3>Action Scoring</h3>
        <pre><code>
Score(a) = R(a) - C(a)
        </code></pre>

        <h3>Validation Conditions</h3>
        <pre><code>
P(a) = 1
I(a) ≥ θ_intent
D(a) ≤ θ_drift
Risk(a) ≤ θ_risk
        </code></pre>

        <p>If any condition fails, Execute(a) = 0 and the event is logged.</p>

        <h3>Execution</h3>
        <pre><code>
a* = argmax Score(a)
Outcome_t = Execute(a*)
        </code></pre>

        <h3>Learning</h3>
        <pre><code>
M_{t+1} = Update(M_t, Outcome_t)
        </code></pre>

        <h3>Optimization Objective</h3>
        <pre><code>
Maximize Σ U(S_t, M_t)
Subject to:
- Permission constraints
- Data minimization
- Risk bounds
- Drift containment
- User sovereignty
        </code></pre>

      </div>
    </section>

    <section class="section fade">
      <h2>Deployment Architecture — Local Sovereignty Model</h2>

      <p>
        Artificial Persistent Intelligence operates under a hybrid model:
        local sovereignty by default, cloud acceleration by permission.
      </p>

      <h3>1. Local Core (Always On)</h3>
      <ul>
        <li>User identity verification and confidence scoring</li>
        <li>Permission enforcement and scope control</li>
        <li>Integrity validation gate</li>
        <li>Drift detection</li>
        <li>Encrypted user model storage</li>
        <li>Immutable audit logging</li>
      </ul>

      <p>
        The Local Core is the authority layer.
        It cannot be overridden by external services.
        It enforces all validation before any action occurs.
      </p>

      <h3>2. Cloud Acceleration (Optional)</h3>
      <ul>
        <li>Large-scale reasoning tasks</li>
        <li>Long-form synthesis</li>
        <li>Heavy compute operations</li>
        <li>Model augmentation</li>
      </ul>

      <p>
        Cloud usage is:
      </p>
      <ul>
        <li>Explicitly authorized</li>
        <li>Minimal-context only</li>
        <li>Redacted when possible</li>
        <li>Blocked if integrity gates fail</li>
      </ul>

      <h3>3. Zero-Trust Mediation</h3>
      <p>
        All communication between Local Core and Cloud services passes through
        the Integrity Gate. No direct execution path exists.
      </p>

      <pre><code>
User → Local Core → Integrity Gate → (Optional) Cloud → Return → Validate → Execute
      </code></pre>

      <h3>Principle</h3>
      <p>
        Local sovereignty. Cloud acceleration. Zero-trust enforcement.
      </p>
    </section>

    <footer class="fade">Architecture · API</footer>
  </main>

  <script>
    (() => {
      const navLinks = document.querySelector('.nav-links');
      const toggle = document.querySelector('.menu-toggle');
      if (toggle && navLinks) {
        toggle.addEventListener('click', () => navLinks.classList.toggle('open'));
        navLinks.querySelectorAll('a').forEach(link => link.addEventListener('click', () => navLinks.classList.remove('open')));
      }
      const observer = new IntersectionObserver(entries => {
        entries.forEach(entry => { if (entry.isIntersecting) entry.target.classList.add('visible'); });
      }, { threshold: 0.15 });
      document.querySelectorAll('.fade').forEach(el => observer.observe(el));
    })();
  </script>
</body>
</html>
